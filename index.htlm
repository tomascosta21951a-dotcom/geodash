<!doctype html>
<html lang="pt-PT">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Geometric Dash ‚Äî Template</title>
<style>
  :root{--bg:#0f1724;--panel:#0b1220;--accent:#ffde59}
  body{margin:0;font-family:Inter,system-ui,Arial;background:var(--bg);color:#e6eef8;display:flex;gap:12px;padding:12px;height:100vh;box-sizing:border-box}
  #left {flex:1;display:flex;flex-direction:column;gap:8px}
  #canvasWrap {background:linear-gradient(180deg,#071025 0%, #0b1830 100%);border-radius:8px;padding:10px}
  canvas{display:block;background:#071221;border-radius:6px; width:100%; height:360px}
  .panel{background:var(--panel);padding:10px;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,0.5)}
  .row{display:flex;gap:8px;align-items:center}
  button{background:var(--accent);border:none;padding:8px 10px;border-radius:6px;cursor:pointer;font-weight:600}
  select,input,textarea{background:#081424;border:1px solid #193246;color:#cfe8ff;padding:6px;border-radius:6px}
  label{font-size:13px;color:#9fc2ff}
  #editor textarea{width:100%;height:160px;background:#061427;color:#d9f0ff;padding:8px;border-radius:6px;border:1px solid #154057}
  small {color:#7ea8ff}
  .flex-between{display:flex;justify-content:space-between;align-items:center}
  .avatar-preview{width:48px;height:48px;border-radius:6px;background:#0b1220;display:flex;align-items:center;justify-content:center;border:1px solid #123;}
</style>
</head>
<body>

<div id="left">
  <div id="canvasWrap" class="panel">
    <div class="flex-between" style="margin-bottom:8px">
      <div>
        <strong>Geometric Dash ‚Äî Template</strong><br><small>Pressiona SPACE para saltar ‚Ä¢ R para reiniciar</small>
      </div>
      <div>
        <span id="score">Score: 0</span> ‚Ä¢ <span id="best">Best: 0</span>
      </div>
    </div>
    <canvas id="game" width="800" height="360"></canvas>
  </div>

  <div class="panel row">
    <label for="levelSelect">N√≠vel:</label>
    <select id="levelSelect"></select>
    <button id="startBtn">Iniciar/Restart</button>
    <button id="openEditorBtn">Editor</button>
  </div>

  <div id="controls" class="panel row">
    <div>
      <label for="themeSelect">Tema Musical:</label>
      <select id="themeSelect">
        <option value="bouncy">Bouncy</option>
        <option value="dark">Dark</option>
        <option value="fast">Fast</option>
      </select>
    </div>
    <div style="margin-left:auto;" class="row">
      <label>Avatar:</label>
      <div class="avatar-preview" id="avatarPreview"></div>
    </div>
  </div>
</div>

<div id="right" style="width:380px;display:flex;flex-direction:column;gap:8px">
  <div class="panel">
    <h3 style="margin:0 0 8px 0">Personaliza√ß√£o üé®</h3>
    <div class="row" style="gap:12px">
      <label>Forma:
        <select id="avatarShape">
          <option value="square">Quadrado</option>
          <option value="circle">C√≠rculo</option>
          <option value="triangle">Tri√¢ngulo</option>
        </select>
      </label>
      <label>Cor:
        <input id="avatarColor" type="color" value="#ff6b6b">
      </label>
      <button id="applyAvatar">Aplicar</button>
    </div>
  </div>

  <div class="panel" id="editor">
    <div class="flex-between"><strong>Editor de n√≠veis (JSON)</strong><small>Guarda no localStorage</small></div>
    <textarea id="levelData"></textarea>
    <div style="display:flex;gap:8px;margin-top:8px">
      <button id="saveLevel">Guardar</button>
      <button id="loadLevel">Carregar</button>
      <button id="testLevel">Testar</button>
    </div>
  </div>

  <div class="panel">
    <strong>Dicas</strong>
    <ul>
      <li>Cria obst√°culos como objetos com x, y, largura, altura e tempo/posi√ß√£o.</li>
      <li>Editor guarda n√≠veis por nome no localStorage.</li>
      <li>Temas musicais usam WebAudio ‚Äî podes ligar samples externos se quiseres.</li>
    </ul>
  </div>
</div>

<script>
/* ======= GAME + LEVEL SYSTEM ======= */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let W = canvas.width, H = canvas.height;
window.addEventListener('resize', ()=>{ /* responsive not required for simple template */ });

/* Player (avatar) */
const player = {
  x: 100, y: H-60, w:40, h:40,
  vy:0, onGround:true,
  color:'#ff6b6b',
  shape:'square',
};

/* Level definitions (example) */
const defaultLevels = [
  {name:'Tutorial', speed:3, gravity:0.9, obstacles:[
    {x:900,w:30,h:60,y:0}, {x:1200,w:30,h:80,y:0}, {x:1600,w:30,h:120,y:0}
  ]},
  {name:'Rush', speed:4.8, gravity:0.9, obstacles:[
    {x:900,w:40,h:100,y:0},{x:1100,w:30,h:80,y:0},{x:1350,w:50,h:140,y:0},{x:1600,w:30,h:70,y:0}
  ]}
];

let levels = JSON.parse(localStorage.getItem('gd_levels') || 'null') || defaultLevels;
let currentLevelIndex = 0;

/* UI refs */
const levelSelect = document.getElementById('levelSelect');
const startBtn = document.getElementById('startBtn');
const scoreEl = document.getElementById('score');
const bestEl = document.getElementById('best');
const levelDataTA = document.getElementById('levelData');
const openEditorBtn = document.getElementById('openEditorBtn');
const saveLevelBtn = document.getElementById('saveLevel');
const loadLevelBtn = document.getElementById('loadLevel');
const testLevelBtn = document.getElementById('testLevel');
const themeSelect = document.getElementById('themeSelect');
const avatarShape = document.getElementById('avatarShape');
const avatarColor = document.getElementById('avatarColor');
const applyAvatarBtn = document.getElementById('applyAvatar');
const avatarPreview = document.getElementById('avatarPreview');
const bestKey = k => 'gd_best_'+k;

/* Game state */
let obstacles = [];
let tick = 0;
let score = 0;
let running = false;
let speed = 3;
let gravity = 0.9;

/* Audio: simple theme generator via WebAudio */
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
let themeNode = null;

function startAudioCtx(){
  if(!audioCtx) audioCtx = new AudioCtx();
}

/* create a simple loop using oscillator + gain scheduling */
function playTheme(name, bpm=120){
  startAudioCtx();
  stopTheme();
  const rootGain = audioCtx.createGain(); rootGain.gain.value = 0.06; rootGain.connect(audioCtx.destination);
  const osc = audioCtx.createOscillator(); osc.type='sine';
  const now = audioCtx.currentTime;
  let pattern;
  if(name==='bouncy'){ pattern=[0,3,5,7]; osc.type='sawtooth'; bpm=100; }
  else if(name==='dark'){ pattern=[0,1,0,1,3,1]; osc.type='triangle'; bpm=70; }
  else if(name==='fast'){ pattern=[0,4,7,9]; osc.type='square'; bpm=140; }
  else { pattern=[0,3,5,7]; }
  let step = 60/bpm;
  // schedule many notes ahead in a loop
  const master = audioCtx.createGain(); master.gain.value = 0.08; master.connect(audioCtx.destination);
  const loopLength = pattern.length * step;
  let idx=0;
  themeNode = {stop:()=>{}, name};
  const playLoop = ()=>{
    const now = audioCtx.currentTime;
    for(let i=0;i<pattern.length;i++){
      const t = now + i*step;
      const o = audioCtx.createOscillator();
      o.type = osc.type;
      const freq = 220 * Math.pow(2, pattern[i]/12);
      o.frequency.setValueAtTime(freq, t);
      const g = audioCtx.createGain(); g.gain.setValueAtTime(0, t);
      g.gain.linearRampToValueAtTime(1, t+0.01);
      g.gain.linearRampToValueAtTime(0, t+step*0.9);
      o.connect(g); g.connect(rootGain);
      o.start(t); o.stop(t+step*0.95);
    }
    themeNode._timeout = setTimeout(playLoop, loopLength*1000 - 50);
  };
  playLoop();
  themeNode.stop = ()=>{
    clearTimeout(themeNode._timeout);
  };
}

function stopTheme(){ if(themeNode && themeNode.stop) themeNode.stop(); themeNode=null; }

/* Populate level selector */
function refreshLevelList(){
  levelSelect.innerHTML = '';
  levels.forEach((lv,i)=>{
    const opt = document.createElement('option'); opt.value=i; opt.textContent = lv.name || 'Level '+(i+1);
    levelSelect.appendChild(opt);
  });
}
refreshLevelList();

/* Load a level into runtime obstacles */
function loadLevel(index){
  const lv = levels[index];
  currentLevelIndex = index;
  speed = lv.speed || 3;
  gravity = lv.gravity || 0.9;
  // create obstacle clones with runtime x
  obstacles = (lv.obstacles||[]).map(o=>({
    x: o.x, w:o.w, h:o.h, y: H - (o.h + 40) // ground offset 40
  }));
  // reset player
  player.y = H-60; player.vy=0; player.onGround=true;
  tick=0; score=0;
  scoreEl.textContent = 'Score: 0';
  bestEl.textContent = 'Best: ' + (localStorage.getItem(bestKey(lv.name)) || 0);
}

/* Start/restart */
function startGame(){
  loadLevel(currentLevelIndex);
  running=true;
  stopTheme();
  playTheme(themeSelect.value);
}
startBtn.addEventListener('click', ()=>{ startGame(); });

levelSelect.addEventListener('change', (e)=>{
  currentLevelIndex = parseInt(e.target.value);
  loadLevel(currentLevelIndex);
});

/* Editor buttons */
openEditorBtn.addEventListener('click', ()=>{
  const lv = levels[currentLevelIndex];
  levelDataTA.value = JSON.stringify(lv, null, 2);
  levelDataTA.scrollIntoView({behavior:'smooth'});
});
saveLevelBtn.addEventListener('click', ()=>{
  try{
    const json = JSON.parse(levelDataTA.value);
    levels[currentLevelIndex] = json;
    localStorage.setItem('gd_levels', JSON.stringify(levels));
    refreshLevelList();
    alert('N√≠vel guardado!');
  }catch(err){ alert('JSON inv√°lido: '+err.message); }
});
loadLevelBtn.addEventListener('click', ()=>{
  const lv = levels[currentLevelIndex];
  levelDataTA.value = JSON.stringify(lv, null, 2);
});
testLevelBtn.addEventListener('click', ()=>{
  try{
    const json = JSON.parse(levelDataTA.value);
    // temporarily set as current level for testing
    levels[currentLevelIndex] = json;
    localStorage.setItem('gd_levels', JSON.stringify(levels));
    refreshLevelList();
    startGame();
  }catch(err){ alert('JSON inv√°lido: '+err.message); }
});

/* Avatar customization */
function drawAvatarPreview(){
  const s = avatarPreview;
  s.innerHTML = '';
  const svgNS = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgNS,'svg');
  svg.setAttribute('viewBox','0 0 48 48'); svg.setAttribute('width','48'); svg.setAttribute('height','48');
  const shape = player.shape;
  if(shape==='square'){
    const r = document.createElementNS(svgNS,'rect'); r.setAttribute('x',6); r.setAttribute('y',6);
    r.setAttribute('width',36); r.setAttribute('height',36); r.setAttribute('rx',6); r.setAttribute('fill',player.color);
    svg.appendChild(r);
  } else if(shape==='circle'){
    const c = document.createElementNS(svgNS,'circle'); c.setAttribute('cx',24);c.setAttribute('cy',24);c.setAttribute('r',16);c.setAttribute('fill',player.color);
    svg.appendChild(c);
  } else {
    const p = document.createElementNS(svgNS,'polygon'); p.setAttribute('points','24,8 40,36 8,36'); p.setAttribute('fill',player.color);
    svg.appendChild(p);
  }
  s.appendChild(svg);
}
applyAvatarBtn.addEventListener('click', ()=>{
  player.color = avatarColor.value;
  player.shape = avatarShape.value;
  drawAvatarPreview();
});
drawAvatarPreview();

/* Input handling */
let keys = {};
window.addEventListener('keydown', e=>{
  if(e.code==='Space'){ e.preventDefault(); if(player.onGround){ player.vy = -14; player.onGround=false; } }
  if(e.key==='r' || e.key==='R'){ startGame(); }
  keys[e.code]=true;
});
window.addEventListener('keyup', e=>{ keys[e.code]=false; });

/* Collision AABB */
function rectsOverlap(a,b){
  return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}

/* Main loop */
function update(dt){
  if(!running) return;
  tick += dt;
  // physics
  player.vy += gravity;
  player.y += player.vy;
  if(player.y + player.h >= H-20){ player.y = H-20 - player.h; player.vy = 0; player.onGround = true; }
  // move obstacles left
  for(let ob of obstacles){
    ob.x -= speed;
  }
  // spawn more obstacles based on level definition (simple)
  const lv = levels[currentLevelIndex];
  // score increase when obstacles pass player
  for(let ob of obstacles){
    if(!ob._passed && ob.x + ob.w < player.x){
      ob._passed = true; score += 1; scoreEl.textContent = 'Score: '+score;
      // update best
      const bKey = bestKey(lv.name);
      const prevBest = parseInt(localStorage.getItem(bKey) || '0');
      if(score > prevBest){ localStorage.setItem(bKey, score); bestEl.textContent = 'Best: '+score; }
    }
    // collision
    const pRect = {x:player.x, y:player.y, w:player.w, h:player.h};
    const oRect = {x:ob.x, y:ob.y, w:ob.w, h:ob.h};
    if(rectsOverlap(pRect,oRect)){
      running=false;
      stopTheme();
      alert('Colis√£o! Score: '+score);
    }
  }
  // remove offscreen obstacles
  obstacles = obstacles.filter(o=> o.x + o.w > -200);
  // if empty (level cleared), finish
  if(obstacles.length===0){
    running=false;
    stopTheme();
    alert('N√≠vel conclu√≠do! Score: '+score);
  }
}

function draw(){
  ctx.clearRect(0,0,W,H);
  // ground
  ctx.fillStyle = '#091227'; ctx.fillRect(0,H-40,W,40);
  // obstacles
  for(let ob of obstacles){
    ctx.fillStyle = '#79b6ff';
    ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
  }
  // player (avatar)
  ctx.save();
  ctx.translate(player.x + player.w/2, player.y + player.h/2);
  ctx.fillStyle = player.color;
  if(player.shape==='square'){
    ctx.fillRect(-player.w/2, -player.h/2, player.w, player.h);
  } else if(player.shape==='circle'){
    ctx.beginPath(); ctx.arc(0,0,player.w/2,0,Math.PI*2); ctx.fill();
  } else { // triangle
    ctx.beginPath(); ctx.moveTo(0,-player.h/2); ctx.lineTo(player.w/2,player.h/2); ctx.lineTo(-player.w/2,player.h/2); ctx.closePath(); ctx.fill();
  }
  ctx.restore();
}

/* animation loop */
let last = performance.now();
function loop(now){
  const dt = (now - last)/1000;
  last = now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* Initialize first level */
loadLevel(0);
levelSelect.value = 0;

/* Theme change handler */
themeSelect.addEventListener('change', ()=>{
  if(running){ stopTheme(); playTheme(themeSelect.value); }
});

/* Save default levels to localStorage if none */
if(!localStorage.getItem('gd_levels')) localStorage.setItem('gd_levels', JSON.stringify(levels));

</script>
</body>
</html>
